## 3.1 对象

前面我们了解到在加载的第三步是在堆内存中生成一个java.lang.class对象，那么一个对象怎么知道它是有哪个类创建的呢？怎么记录呢？一个对象中有哪些信息呢？

![image-20210517234012173](..\imgs\image-20210517234012173.png)

### 3.1.1 对象组成验证

我们可以验证一下。

首先我们要引用一个jar包，输出我们的对象机构

```xml
<dependency>
    <groupId>org.openjdk.jol</groupId>
    <artifactId>jol-core</artifactId>
    <version>0.10</version>
</dependency>
```

创建一个Demo类

```java
public class Demo {
    private int a;
    private double b;
    private byte u;
    public static void main(String[] args) {
        Demo demo = new Demo();
        System.out.println(demo.hashCode());
        System.out.println(ClassLayout.parseInstance(demo).toPrintable());
    }
}
```

输出结果

```txt
2001049719
com.example.spidemo.Demo object internals:
 OFFSET  SIZE     TYPE DESCRIPTION                               VALUE
      0     4          (object header)                           01 77 98 45 (00000001 01110111 10011000 01000101) (1167619841)
      4     4          (object header)                           77 00 00 00 (01110111 00000000 00000000 00000000) (119)
      8     4          (object header)                           05 c1 00 f8 (00000101 11000001 00000000 11111000) (-134168315)
     12     4      int Demo.a                                    0
     16     8   double Demo.b                                    0.0
     24     1     byte Demo.u                                    0
     25     7          (loss due to the next object alignment)
Instance size: 32 bytes
Space losses: 0 bytes internal + 7 bytes external = 7 bytes total
```

![image-20210518000330319](..\imgs\image-20210518000330319.png)

这里我们延伸一下，我们输出demo的hashcode为2001049719，我们把这个数换成16进制后结果为7745 9877，对比上面的输出结果是不是有些眼熟。

![image-20210518000653935](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210518000653935.png)

这里得提到两个概念，**大端存储**，**小端存储**。

什么是大小端呢？

数据的高低位：高位--------------------------------低位

地址的高低位：低地址--------------------------------高地址

![image-20210518073919671](..\imgs\image-20210518073919671.png)

小端存储：低存低，高存高

大端存储：低存高，高存低

**由此我们可以知道哈希码是大端存储**

**小端存储**：便于数据之间的转化。比如long转换int 直接舍弃高地址位置

**大端存储**：便于符号判断，低地址位置既为符号位，可以直接判断数据的正负号。

### 3.1.2 Class Point

引用怎么定位到对象呢？有两种方式：

- **句柄池访问**

  句柄池访问在java堆中另分配一个地址，存储指向对象实例的指针，和存储指向对象类型数据的指针，reference存储的是指向句柄池中的指针位置地址，所以当实例对象移动时，reference中地址是不变的，改变的是句柄池中指针。但是这也多带来了一次指针定位开销。

![image-20210518075120993](..\imgs\image-20210518075120993.png)

- **直接访问**

  直接访问，reference存放对象实例地址，由对象实例自己存储对象类型数据指针。这样也减少了一次指针寻址，但当对象位置发生改变时，reference存储的地址也需要发生改变。

![image-20210518075339797](..\imgs\image-20210518075339797.png)

### 3.1.3 对齐填充

64位的计算机，每次寻址都是8个字节，如果我们存储的数据大于8字节，我们寻址的次数就会大于1，但当我们一个小于8字节数据，存储两个8字节之间，那么本该只需一次寻址，我们却需要两次。看图

![image-20210518081506192](..\imgs\image-20210518081506192.png)

从上图我们可以看到，如果我们要去访问这个long类型的数据，我们需要两次寻址。这会降低了效率。这时我们如果用空位补齐，会怎么样呢？

![image-20210518081959189](..\imgs\image-20210518081959189.png)

这样我们访问这个long类型，只需要一次寻址就可以了，但发明计算机的人肯定不傻，对齐填充时，多余出来的空间一定会利用起来的。这里我就不在画图了。

## 3.2 堆

前面我们已经说过运行数据区，其中关于堆的部分也讲了一些，现在这一块主要讲的堆的推演。

堆在我们运行时数据区分配了一部分内存，但是堆的结构是怎么样的呢？

首先在堆中创建对象时，随着一次次的垃圾回收，总有些对象是不被回收的，这个时候我们一般认为，经过多次回收都不死去的对象，应该是很难死去的对象，我们需要把这群对象放到一起，对它们的gc就不应该那么频繁了，这群很安放很难死去对象的区域，我们称之为old区。这个时候我们已经在堆中画出了一块old区了，那么剩下的区域我们简而言之的称之为young区，这部分区域都是用来分配新的对象，当新的对象，经过长时间不被回收我们就把这种不被回收的对象，移到old区。经过统计百分之98的对象都是朝生夕死的，也就是说，大部分对象经历不了几次垃圾回收的。

但是在young区分配对象时，随机垃圾回收的次数的增加，young区本来有100M空间，经过几次垃圾回收，还剩20M空间，但是真的来了一个20M对象，却放不下去，因为，young区经过几次垃圾回收后，空间并不连续，也就是我们常说的空间碎片，那么这个问题该怎么解决呢？这个时候，又在young区划分为两个空间，一个Eden区，一个survivor区，Eden区用来分配新出生的对象，当这些对象，经过垃圾回收的时候，还存活的话，我们就给他们移到survivor区，也就是我们常说的s区，其实这个时候，我们会发现，s区也会出现我们上面所说young区的问题，明明空间还够，但是对象放不进去，这个时候，我们可以再s区划分为s0和s1区，存活的对象放到s0，当经过垃圾回收后，再把存活的对象移到s1，再经过垃圾回收后，又把存活的对象从s1移到s0，就是始终得保证一块区域是空白的连续空间。

在经过多次的s0，s1之间的移动，也就是一个对象经历多次的垃圾回收，默认是15次，也就是我们常说的分代年龄，每经历一次垃圾回收，分代年龄就会+1，当分代年龄到了15的时候，我们就需要将这些对象移动到old区。

但也有特殊情况，当一个新生的对象大到s区都放不下，会直接分配到old区，大哥得有大哥得担当。同理当一个对象，剩余的s区放不下时，也会移动old区。

![image-20210519065514413](..\imgs\image-20210519065514413.png)

![image-20210519071309182](..\imgs\image-20210519071309182.png)

