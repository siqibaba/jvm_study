如果说垃圾回收算法是垃圾回收的方法论，那么垃圾回收器就是垃圾回收的具体实现。

![image-20210523093729417](..\imgs\image-20210523093729417.png)

垃圾回收无非就是两点：

- 收的快

  意味着收的少

- 收的多

  意味着收的慢

## 5.1 Serial

Serial是最基本的，历史最悠久的垃圾收集器，在jdk1.3之前是新生代垃圾收集器的唯一选择。

Serial是单线程垃圾收集器，这不仅仅是单个cpu，单个线程完成垃圾回收工作，更重要的是，在垃圾回收的时候会暂停其他线程，也就是STW(Stop The World)

![image-20210523094759228](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210523094759228.png)

> 优点：简单高效，拥有很高的单线程收集效率。
>
> 缺点：收集过程需要暂停所有线程
>
> 算法：复制算法
>
> 适用范围：新生代
>
> 应用：Client模式下默认新生代垃圾收集器

## 5.2 Serial Old

Serial Old 垃圾收集器是Serial老年代版本，也是一个单线程收集器，不同的是采用标记整理算法，运行过程和Serial收集器一样。

![image-20210523095358149](..\imgs\image-20210523095358149.png)

## 5.3 ParNew

可以把这个收集器理解为Serial多线程版。![image-20210523095609562](..\imgs\image-20210523095609562.png)

> 优点：在多核cpu时，效率比serial高
>
> 缺点：收集过程需要暂停所有线程
>
> 算法：复制算法
>
> 适用范围：新生代
>
> 应用：运行在Server模式下的虚拟机中首选的新生代收集器

## 5.4 Parallel Scavenge

Parallel Scavenge 是新生代的垃圾收集器，也是复制算法，也是多线程，看上去和ParNew一样，但是Parallel Scavenge更关注的是吞吐量。

> 吞吐量 = 运行用户代码时间/（垃圾回收时间+运行用户代码时间）
>
> 吞吐量越大意味着垃圾回收时间越短。

```txt
-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间， 
-XX:GCTimeRatio直接设置吞吐量的大小。
```

## 5.5 Parallel Old

Parallel Scavenge 老年版，使用的多线程和标记整理算法，也是关注吞吐量。

## 5.6 CMS

### 5.6.1 并发步骤

CMS（Concurrent Mark Sweep）垃圾收集器，是以获取最短停顿时间的垃圾收集器。采用的是标记清除算法。

那么怎么让停顿时间变得更短呢？这时可以想到的是，我们能不能把垃圾收集这个大的步骤，把它拆分成一个个小步骤，然后，在这些小步骤中，看看哪些步骤是可并发执行的，哪些步骤是必须要STW的，这样一个大的步骤，就可以将停顿时间变得更短了。CMS是怎么拆的呢？

CMS整个过程分为4个大的步骤。

- 初始标记

  标记GC roots直接关联的对象，不用追踪，这个过程是STW的，但停顿时间非常短

- 并发标记

  进行GC roots追踪。

  因为在标记的过程时，应用线程还在跑，这个时候，可能会有新生代到老年代，有些老年代引用改变，有些对象直接被分配到老年代，这些受到影响的老年代的区域会被标记为Dirty Card。

  那么什么是Card呢？

  CMS垃圾收集器会把老年代划分成一个个512字节的区域，然后用Card table数据结构 记录这些区域的变化。

  那么CMS是怎么知道这些对象发生了变化呢？

  写屏障，当对老年代的对象进行了引用时（也就是赋值），会触发写屏障，会把所在区域的变化反馈给卡表。

  ![image-20210523160519592](..\imgs\image-20210523160519592.png)

- 重新标记

  修改并发标记因用户程序变动的内容，这个过程也是STW。

- 并发清理

  清理掉不可达对象，回收空间，同时会有新的垃圾产生。

![image-20210523101717015](..\imgs\image-20210523101717015.png)

在并发标记和重新标记之间，还有两个步骤，预处理和可终止的预处理。这两个步骤其实还是并发标记的过程，我们接下来细看

- 预处理

  还是用来标记老年代对象，目的是为了让重新标记的时间减少。这个时候会扫描老年代Dirty card区域，新生代survivor区。

- 可中断的预处理

  这个阶段的目标是预处理目标相同，可终止的预处理，在进行重新标记之前，尽量的等到一次minner gc。

  为什么要等Minner GC？

  - 减少重新标记时间
  - 尽量避免Minner gc和重新标记连在一起发生，这样虽然重新标记STW时间很短，但是加上Minner GC的STW的时间，可能整个的STW的时间就很长了。

  > 在预清理步骤后，满足下里面条件就不会开启预处理，直接进入重新标记阶段。
  >
  > ```txt
  > 条件1：Eden的使用空间大于“CMSScheduleRemarkEdenSizeThreshold”，这个参数的默认值是2M；
  > 条件2：Eden的使用率大于等于“CMSScheduleRemarkEdenPenetration”，这个参数的默认值是50%。
  > ```
  >
  > 如果满足条件1，不满足条件2，就会进入可中断的预处理步骤。退出这个阶段的出口有两个。
  >
  > ```txt
  > 设置了CMSMaxAbortablePrecleanLoops，并且执行的次数超过了这个值，这个参数的默认值是0； 
  > CMSMaxAbortablePrecleanTime，执行可中断预清理的时间超过了这个值，这个参数的默认值是5000毫秒
  > ```
  >
  > 也就是说在这个阶段等了5s还没有发生minner gc，就会退出这个阶段。

### 5.6.2 CMS异常情况

- 并发失败

  CMS在并发周期内，应用线程还在进行，这个时候，用户线程向老年请求分配的空间超过了预留的空间（担保失败），就会触发concurrent model failure,然后并发周期就会被full gc 代替，这也是cms另一种收集模式 full background。同时也会整理老年代的内存空间。

  ```txt
  如果我们设置了UseCMSInitiatingOccupancyOnly和CMSInitiatingOccupancyFraction参数，其中CMSInitiatingOccupancyFraction的值是70，那预留空间就是老年代的30%。
  ```

- 晋升失败

  并发周期内，新生代向老年代请求分配空间时，担保机制判断不够，并发失败，担保机制判断是足够的，但是由于空间碎片问题导致无法分配，晋升失败。

- 元空间耗尽

  触发full gc

### 5.6.3 三色标记

三色标记，就是将对象标记为三种颜色

- 黑色
  - 所有引用都被扫描到
  - 黑色不能直接指向白色
  - 不能被回收
- 灰色
  - 对象本身已扫描
  - 至少还有一个引用没被扫描
- 白色
  - 没有被gc扫描
  - 扫描结束后白色可以被回收

**这里其实还有一个问题，怎么知道我还有引用有没有被扫描？**

对象A 引用对象 B，那么怎么存储这个引用呢？

**Point out：**对象A存储了对象B的地址（CMS）

**Point in：**：对象B存储了对象A对自己的引用（G1）

## 5.7 G1

### 5.7.1 简介

G1(GarbageFirst)垃圾优先收集器，它像是Parallel Scvenge和CMS的结合，为什么这么说呢？因为它可以和Parallel Scavenge一样调整STW时间，和吞吐量。同时它的收集步骤又和CMS差不多，将垃圾回收拆成了多个步骤，有些步骤是并发的，有些步骤是STW。

G1把堆划分成一个个大小一样的Region，每个Region的大小为1-32M（2的N次方），一般默认为2048个Region，G1摒弃了将堆中的Eden区，s区，old区严格的划分。

每个Region，它定义不是固定的，它既可能在这次垃圾回收时是Eden区，但在下次垃圾回收时是Old区，或Humongous区，它是可以转化的。

> 什么样的对象被定义为大对象？放到H区
>
> 当一个对象的大小大于一个Region的50%时，就是大对象，需要放到H区



![image-20210523195442509](..\imgs\image-20210523195442509.png)

### 5.7.2 G1的工作步骤

- 初始标记

  标记GC roots能够关联的对象，并且修改TAMS的值，需要暂停线程。

- 并发标记

  从GC roots进行可达性分析，找出存活对象，与用户线程同时进行。

- 最终标记

  修正并发标记时，因用户线程的并发执行，导致变动的数据，需要暂停用户线程。

- 筛选清理

  对各个Region的回收价值和成本进行排序，根据用户所期望的最短停顿时间制定进行回收计划。

### 5.7.3 Rset

Rset （Remember Set），可以看做卡表的升级版，它由三种数据结构组成。

- 稀疏表 它在Region上面开辟一块大概5%-10%的空间，key-Value模式，key为Region的起始地址，Value为卡页数据的索引号。

- 细粒度位图

  每一个Region会被分为一个个512kb的卡页，细粒度位图，就是记录每个卡页其中是否有对象指向新生代。![image-20210524075010040](..\imgs\image-20210524075010040.png)

- 粗粒度位图

  当卡页数量足够多的时候，细粒度位图就会升级为粗粒度位图，就是记录每个Region中是否有对象指向新生代。

### 5.7.4 G1的gc分类

- young gc
  - STW
  - 选择所有新生代Region
  - 根扫描
  - 更新Rset，记录引用变化
  - 复制
  - 重构Rset
  - 释放
  - 大对象回收
  - 动态扩展内存
- Mixed gc
  - young gc
  - 收益高的old区
  - -XX:MixedGcCountTarget = 8 ，就是将old区分为8个部分，每次回收8分之一
- full gc
  - 单线程

### 5.7.5 TLAB

TLAB （Thread Local Allocation Buffer）本地线程分配缓冲区

### 5.7.6 栈上分配

方法内的一些对象，会将它分配到局部变量表中，当方法执行完，随着线程一起被回收。
