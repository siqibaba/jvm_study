## 4.1 对象的生命周期

### 4.1.1 生命周期

jvm垃圾回收，回收的是什么，是java对象，所以在谈到j垃圾回收之前，我们一定要先了解java对象的生命周期。

java对象的生命周期主要包括下面几个：

- 创建阶段

  在类加载的时候我们已经谈论过了

  > 为对象分配存储空间
  >
  > 开始构造对象
  >
  > 从超类到子类static成员初始化
  >
  > 超类成员变量初始化，递归超类构造方法
  >
  > 子类成员变量初始化，子类构造方法调用
  >
  > 一旦对象被创建，并且成员变量被赋值，这个对象状态就切换到应用阶段。

- 应用阶段

  对象至少被一个强引用引用

- 不可见阶段

  当一个对象处于不可见阶段，说明程序本身不该再持有这个对象强引用，虽然这些引用仍然是存在的。

  简单的说，程序执行已经超过了该对象的区域了。

- 不可达阶段

  对象不再被任何强引用持有，

- 收集阶段

  当垃圾回收器发现，该对象已经是不可达阶段，并垃圾回收器已经做好对该对象内存空间重新分配的准备，则该对象进入了收集阶段，如果该对象已经重写了finalize()方法，则会执行该方法的终端操作。

  特别说明一下：不要进行重载finalize()方法。

  - 会影响jvm对象分配和回收效率
  - 该死的对象重新复活，不利于后续代码管理。

- 终结阶段

  等待垃圾回收器对对象进行回收

- 对象空间重分配阶段

  垃圾回收器对该对象的内存空间进行回收和重新分配，该对象彻底消失了。

![image-20210519075128152](..\imgs\image-20210519075128152.png)

### 4.1.2 引用类型

java的引用类型定义很传统，如果一个引用类型中存储值代表另一块内存，就称这块内存代表一个引用。这种定义很纯粹，但很狭隘，一个对象在这种定义下，只有被引用和不被引用。很表达那种想扔又舍不得扔的对象。也难表达那种判刑中的对象。

我们希望能描述那种，空间足够时，就保存在内存中对象；经过垃圾回收空间还很紧张，则可抛弃的对象。很多系统缓存都符合这种场景。

一些引用随之诞生：

- 强引用

  强引用，java中最常见的引用，把对象赋值给一个引用变量，这个引用变量就是强引用。当一个对象是可达状态时，是永远不会被jvm回收的。所以强应用是造成java内存泄漏的主要原因之一。

- 软引用

  软引用需要用softReference来实现，软引用对象，当内存充足时，不会被回收，当系统内存不足时，才被回收。软引用一般用在对内存要求敏感的项目中。

  ```java
  public static void main(String[] args) throws InterruptedException {
      Demo demo = new Demo();
      SoftReference<Demo> softReference = new SoftReference<>(demo);
  
      demo = null;
  
      System.gc();
      Thread.sleep(2000);
      if (softReference.get() != null){
          demo = softReference.get();
          System.out.println(demo);
      }
  
  }
  ```

  ![image-20210521071242412](..\imgs\image-20210521071242412.png)

- 弱引用

  弱引用用WeakReference来实现，弱引用对象，只要进行了一次gc，不系统内存是否充足，就会被回收。

  ```java
  public static void main(String[] args) throws InterruptedException {
      Demo demo = new Demo();
      WeakReference<Demo> wr = new WeakReference<>(demo);
      System.out.println("第一次gc前："+demo);
      System.out.println("第一次gc前："+wr.get());
  
      System.gc();
      Thread.sleep(2000);
      System.out.println("第一次gc后："+demo);
      System.out.println("第一次gc后："+wr.get());
  
      demo = null;
      System.gc();
      Thread.sleep(2000);
      System.out.println("第二次gc后："+ demo);
      System.out.println("第二次gc后："+ wr.get());
  }
  ```

  ![image-20210521071801461](..\imgs\image-20210521071801461.png)

- 虚引用

  虚引用需要phantomReference来实现，它不能单独使用，必须和联合队列一起使用，虚引用主要作用是跟踪对象被垃圾回收的状态。

## 4.2 垃圾回收

### 4.2.1 什么时候会垃圾回收

GC是由jvm自动完成的，根据jvm的环境而定，所以时机是不确定的。当然我们也能手动gc，比如调用System.gc()方法，通知jvm进行垃圾回收，但是jvm何时进行垃圾回收，是由jvm决定的，但只要你发了这个通知，jvm一定会进行gc。那么有哪些情况下会发生gc呢？

- Eden区或S区空间不够的时候
- Old区空间不够的时候
- 方法区空间不够的时候
- 调用System.gc()

### 4.2.2 垃圾回收算法

​	已经可以确定一个对象是垃圾了，接下来就得考虑回收了，那么怎么回收呢？得有对应的算法，下面我们说说常见的垃圾回收算法。

#### 4.2.2.1 标记-清除算法

- 标记

  找出内存中垃圾对象，进行标记。标记需要将整个内存都扫一遍，比较耗时。![image-20210521073849610](..\imgs\image-20210521073849610.png)

- 清除

  将标记为垃圾的对象，进行回收，释放内存空间。

  ![image-20210521074103527](..\imgs\image-20210521074103527.png)

> 标记清除算法的缺点
>
> - 一次要扫描整个内存空间，比较耗时
> - 容易产生大量的空间碎片，当下次有大对象过来，无法分配内存，从而触发下一次gc。

#### 4.2.2.2 标记-复制算法

将内存划分为两块区域，每次使用其中一块内存。

![image-20210521075138854](..\imgs\image-20210521075138854.png)

当其中一块区域使用完了，将存活的对象复制到另一块区域，然后把使用掉的内存，一次清理掉。

![image-20210521075404739](..\imgs\image-20210521075404739.png)

> 缺点：
>
> 空间利用率低。



#### 4.2.2.3 标记-整理算法

复制算法在对象存活率较高时就会进行较多的复制操作，效率会降低。更关键的是，如果不想浪费50%的空间，就要额外的空间，进行分配担保，以应对被使用内存中对象100%存活的极端情况。所以老年代一般不能直接选用复制收集算法。

标记算法和清除算法一下，但是后续步骤不是直接对算法进行清理，而是让存活对象都向一端移动，然后直接清理掉端边界外的内存。

![image-20210521080351917](..\imgs\image-20210521080351917.png)

让所有对象都向一端移动，清理掉端边界以外的对象

![image-20210521080629532](..\imgs\image-20210521080629532.png)

